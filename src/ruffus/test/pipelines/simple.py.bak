#!/usr/bin/env python2.5
"""

    test_tasks.py

"""


#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

#   options        


#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

from optparse import OptionParser
import sys, os
import os.path
import StringIO

# add self to search path for testing
exe_path = os.path.split(os.path.abspath(sys.argv[0]))[0]
if __name__ == '__main__':
    module_name = os.path.split(sys.argv[0])[1]
    module_name = os.path.splitext(module_name)[0];
else:
    module_name = __name__

# graph, task etc are one directory down
if __name__ == '__main__':
    sys.path.append("/net/cpp-group/Leo/inprogress/pipeline/installation/src/pypeline")



parser = OptionParser(version="%prog 1.0")
parser.add_option("-u", "--uptodate_job_names", dest="uptodate_job_names",
                  action="append",
                  metavar="JOBNAME", 
                  default = list(),
                  type="string",
                  help="nodes to terminate on.")
parser.add_option("-t", "--target_job_names", dest="target_job_names",
                  action="append",
                  default = list(),
                  metavar="JOBNAME", 
                  type="string",
                  help="nodes to start on.")
parser.add_option("-f", "--forced_job_names", dest="forced_job_names",
                  action="append",
                  default = list(),
                  metavar="JOBNAME", 
                  type="string",
                  help="nodes to start on.")
parser.add_option("-v", "--verbose", dest = "verbose",
                                  action="store_true", default=False,
                                  help="Do not echo to shell but only print to log.")
parser.add_option("-d", "--dependency", dest="dependency_file",
                  default="simple.svg",
                  metavar="FILE", 
                  type="string",
                  help="name and path of dependency graph file")
parser.add_option("-z", "--horizontal_graph", dest="horizontal_graph",
                                  action="store_true", default=False,
                                  help="Draw dependency graph horizontally")
parser.add_option("--skip_children", dest="skip_children",
                                  action="store_true", default=False,
                                  help="Only draw from targets")
parser.add_option("--skip_up_to_date", dest="skip_up_to_date",
                                  action="store_true", default=False,
                                  help="Only draw tasks which need to be rerun")
parser.add_option("-F", "--format_of_dependency", dest="format_of_dependency",
                  metavar="FORMAT", 
                  type="string",
                                  default = 'svg',
                  help="format of dependency graph file. Can be 'ps' (PostScript), "+
                                  "'svg' 'svgz' (Structured Vector Graphics), " +
                                  "'png' 'gif' (bitmap  graphics) etc ")

parameters = [  
                "uptodate_job_names"
                ]







#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

#   imports        


#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

import StringIO
import re
import operator
import sys
from collections import defaultdict

from graph import *
from task import *
from print_dependencies import *
import json

#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

#   Functions


#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888







#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888

#   Main logic


#88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888





# get help string
f =StringIO.StringIO()
parser.print_help(f)
helpstr = f.getvalue()
(options, remaining_args) = parser.parse_args()










import time
def handle_task_files_io_for_testing(params):
    (infiles, outfiles) = params[0:2]
    
        
    if isinstance(infiles, str):
        infiles = [infiles]
    elif infiles == None:
        infiles = []
    if isinstance(outfiles, str):
        outfiles = [outfiles]
    output_text = list()
    for f in infiles:
        output_text.append(open(f).read())
    output_text = "".join(sorted(output_text))
    output_text += json.dumps(infiles) + " -> " + json.dumps(outfiles) + "\n"
    for f in outfiles:
        open(f, "w").write(output_text)
    time.sleep(1)
 
       
@files([None, ['a.1', 'b.1', 'c.1', 'd.1'], "extra param"])
def task1(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)

    
@files_re('*.1', '(.*).1', r'\1.2')
@follows("task1")
def task2(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)


@files_re(['a.1', 'b.1', 'c.1', 'd.1'], '(.*).1', r'\1.4')
@follows("task3", task2)
def task4(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)




@files(['a.2', 'a.3', 1], ['b.2', ['b.3', 'b.3b'], 2])
@follows(task2)
def task3(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)


@files([['a.4', 'b.4', 'c.4', 'd.4'], 'both.5', 4, 5])
@follows("task5")
def finaltask(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)


@files_re(['a.1', 'b.1', 'c.1', 'd.1'], '(.*).1', r'\1.4')
@follows(task4)
def task5(*params):
    sys.stdout.write('    job = %s\n' % json.dumps(params))
    handle_task_files_io_for_testing(params)



if options.dependency_file:
    graph_printout (     open(options.dependency_file, "w"),
                         options.target_job_names, 
                         options.format_of_dependency,
                         options.forced_job_names, 
                         not options.horizontal_graph, 
                         options.skip_children,
                         options.skip_up_to_date)
    
pipeline_run(options.target_job_names, options.forced_job_names, multiprocess = 5)
